0123
4567
89AB
CDEF

a b c d
e c g h
i j k l
m n o p

left  = -1 unless cell%4==0
right = +1 unless cell%4==3
up    = -4 unless cell<4
down  = +4 unless cell>11

find all words as usual, but:
- allow duplicates
- for each word, record the prev bitvector (16 bits)
- for each cell, record the prev bitvector and position in trie for that cell

I've rewritten boggle from scratch in a relatively clean C++ fashion. The
results: 11,000 bds/sec. Unfortunately, that's only half what I got with the
old C version in a single thread.
Update: my old numbers must have been for random letters on a board, not for
true random boggle boards. Perf for the old and new versions is identical when
I run identical tests. Very cool. The main gain of this new codebase is that I'm
not terrified to touch it.

I've written the partial generation code, and (assuming it's actually correct,
which it appears to be) it was surprisingly simple. I suspect the full partial
evaluator is only about twenty lines of code away. The real saving grace in all
of this has been the clean C++ version of the Trie and FoundMark. Without those,
this would have been a complete nightmare. As it is, I'm stunned by the simplicity,
clarity and speed of the core algorithm.

There are more valid paths to each square in the horrible 'abcdefghijklmnop' board
than I'd been expecting. I'd guess an average of about 40 paths to each cell on the
board, though there's significant variation. I'm using STL containers to store
these paths, so I'll need to do some perf testing to see whether that's wise.

Initial results!

I rigged the experimental data to help the mutated board solver.. start w/ a very
high-scoring board ("catdlinemaropets") and try all mutations: 26*16 (not just 6*16,
since I really am rigging this in all possible ways). The numbers are intersting.

Mutated, no precomputation: 17958.950111 bds/sec
Original C++ Boggle:        3267.97 bds/sec
Mutated, including precomp: 505.938604 bds/sec

Clearly there's gains to be had. The mutated scoring is very fast: 23 ms for all
416 boards. But the precomputation is awful: 800 ms for one board. The original
Boggle is ten times slower per board, but doesn't have to pay that startup cost.
I need to look long and hard for optimizations to the precomputation. Cutting
it by a factor of ten would change the results to 4000 bds/sec, which is better
than the old way.

I'll need to run a profiler, but I suspect I'm doing a lot of unnecesary copying
into my STL container. Nope, that wasn't it!

GOD I love C++! I factored out the core DFS Boggle code using templates. The 
template class has push/pop methods (for going in/out in the DFS) and a found
method for finding a word. With inlining, this let me factor out the algorithms
to score/trace/list all words on a board with no performance hit. Fantastic. I
just cut out 80 lines of code from a 240 line file.